var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#","page":"API reference","title":"API reference","text":"Apertures","category":"page"},{"location":"api/#RegisterWorkerApertures.Apertures","page":"API reference","title":"RegisterWorkerApertures.Apertures","text":"alg = Apertures(fixed, nodes, maxshift, λ, [preprocess=identity]; kwargs...) creates a worker-object for performing \"apertured\" (blocked) registration.  fixed is the reference image, nodes specifies the grid of apertures, maxshift represents the largest shift (in pixels) that will be evaluated, and λ is the coefficient for the deformation penalty (higher values enforce a more affine-like deformation). preprocess allows you to apply a transformation (e.g., filtering) to the moving images before registration; fixed should already have any such transformations applied.\n\nAlternatively, λ may be specified as a (λmin, λmax) tuple, in which case the \"best\" λ is chosen for you automatically via the algorithm described in auto_λ.  If you monitor the variable datapenalty, you can inspect the quality of the sigmoid used to choose λ.\n\nRegistration is performed by calling driver.\n\nExample\n\nSuppose your images are somewhat noisy, in which case a bit of smoothing might help considerably.  Here we'll illustrate the use of a pre-processing function, but see also PreprocessSNF.\n\n   # Raw images are fixed0 and moving0, both two-dimensional\n   pp = img -> imfilter_gaussian(img, [3, 3])\n   fixed = pp(fixed0)\n   # We'll use a 5x7 grid of apertures\n   nodes = (linspace(1, size(fixed,1), 5), linspace(1, size(fixed,2), 7))\n   # Allow shifts of up to 30 pixels in any direction\n   maxshift = (30,30)\n   # Try a range of λ values\n   λrange = (1e-6, 100)\n\n   # Create the algorithm-object\n   alg = Apertures(fixed, nodes, maxshift, λrange, pp)\n\n   # Monitor the datapenalty, the chosen value of λ, the deformation\n   # u, and also collect the corrected (warped) image. By asking for\n   # :warped0, we apply the warping to the unfiltered moving image\n   # (:warped would refer to the filtered moving image).\n   # We pre-allocate space for :warped0 to illustrate a trick for\n   # reducing the overhead of communication between worker and driver\n   # processes, even though this example uses just a single process\n   # (see `monitor` for further detail).  The other arrays are small,\n   # so we don't worry about overhead for them.\n   mon = monitor(alg, (), Dict(:λs=>0, :datapenalty=>0, :λ=>0, :u=>0, :warped0 => Array(Float64, size(fixed))))\n\n   # Run the algorithm\n   mon = driver(algorithm, moving0, mon)\n\n   # Plot the datapenalty and see how sigmoidal it is. Assumes you're\n   # `using Immerse`.\n   λs = mon[:λs]\n   datapenalty = mon[:datapenalty]\n   plot(x=λs, y=datapenalty, xintercept=[mon[:λ]], Geom.point, Geom.vline, Guide.xlabel(\"λ\"), Guide.ylabel(\"Data penalty\"), Scale.x_log10)\n\n\n\n\n\n","category":"type"},{"location":"cookbook/#cookbook-1","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"","category":"section"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"To learn how to use this package, we'll use a small 2d image sequence defined in BlockRegistration","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"using Distributed, StaticArrays, RegisterWorkerShell, JLD, FileIO, ImageView\nwpids = addprocs(2)   # add two workers (you can use more if you have the hardware)\n@everywhere using RegisterWorkerApertures, RegisterDriver\n\n#### Load image on the master process\n# Normally this might be `img = load(\"myimagefile\")`, but this is a demo\nusing BlockRegistration                                # just needed for this demo\nbrdir = dirname(dirname(pathof(BlockRegistration)))    # directory of BlockRegistration\ninclude(joinpath(brdir, \"test\", \"gen2d.jl\"));          # defines `img`\n\n#### Choose the fixed image and set up the parameters (this is similar to BlockRegistration)\nfixedidx = (nimages(img)+1) ÷ 2  # ÷ can be obtained with \"\\div[TAB]\"\nfixed = img[time=fixedidx]\n\n# Important: you should manually inspect fixed to make sure there are\n# no anomalies. Do not proceed to the next step until you have done this.\n\n# Choose the maximum amount of movement you want to allow (set this by visual inspection)\nmxshift = (30, 30)  # 30 pixels along each spatial axis for a 2d+time image\n# Pick a grid size for your registration. Finer grids allow more\n# \"detail\" in the deformation, but also have more parameters and\n# therefore require higher SNR data.\ngridsize = (3, 3)   # it's fine to choose something anisotropic\n\n# Choose volume regularization penalty. See the help for BlockRegistration.\nλ = 1e-5\n\n# Compute the nodes from the image and grid\nnodes = map(axes(fixed), gridsize) do ax, g\n    range(first(ax), stop=last(ax), length=g)\nend\n\n#### Set up the workers, the monitor, and run it via the driver\n# Create the worker algorithm structures. We assign one per worker process.\nalgorithm = [Apertures(fixed, nodes, mxshift, λ; pid=wpids[i], correctbias=false) for i = 1:length(wpids)]\n\n# Set up the \"monitor\" which aggregates the results from the workers\nmon = monitor(algorithm, (), Dict{Symbol,Any}(:u=>ArrayDecl(Array{SVector{2,Float64},2}, gridsize)))\n\n# Load the appropriate mismatch package\nmm_package_loader(algorithm)\n\n# Define the output file and run the job\nfileout = \"results.register\"\n@time driver(fileout, algorithm, img, mon)\n\n# Append important extra information to the file\njldopen(fileout, \"r+\") do io\n    write(io, \"fixedidx\", fixedidx)\n    write(io, \"nodes\", nodes)\nend","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"You should see some output showing which workers are working on which time slices.","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"To visualize the results, let's load the deformation and apply it to the image sequence:","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"u = load(fileout, \"u\")\nϕs = griddeformations(u, nodes)   # defined in RegisterDeformation\n\nimgw = similar(img, Gray{Float32});   # eltype needs to be able to store NaN\nfor i = 1:nimages(img)\n    # Apply the deformation to the \"recorded\" image\n    imgw[:,:,i] = warp(img[:,:,i], ϕs[i])\nend","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"(See the documentation for BlockRegistration for how to do this when your images are too large to hold in memory.)","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"Now you can visualize it with imshow(imgw).","category":"page"},{"location":"cookbook/#Key-differences-from-BlockRegistration-1","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Key differences from BlockRegistration","text":"","category":"section"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"Most of the parameters and choices you'll make are similar to what you'd do if you're using BlockRegistration directly. The key changes are that instead of calling the various stages of mismatch calculation and optimization, you instead set up the \"algorithm\" (one per worker), monitor, and call the driver.","category":"page"},{"location":"cookbook/#","page":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","title":"Stack-by-stack optimization with RegisterWorkerApertures: a cookbook","text":"You can read the help for these in the API reference.","category":"page"},{"location":"calcium_imaging/#Notes-on-registering-biological-sequences-1","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"","category":"section"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"When registering image sequences such as those from calcium imaging, sometimes a number of pre-processing stages can be useful.","category":"page"},{"location":"calcium_imaging/#Filtering-and-shot-noise-transformation-1","page":"Notes on registering biological sequences","title":"Filtering & shot-noise transformation","text":"","category":"section"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"PreprocessSNF can be useful to smooth, background-subtract, bias-correct, and transform shot noise into an approximately stationary gaussian process.","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"Here's a demo:","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"# Make sure the pixelspacing property is set correctly; edit the .imagine\n# file with a text editor if necessary or use the AxisArray as above.\nps = pixelspacing(img)\n# Define preprocessing. Here we'll highpass filter over 25μm, but these\n# numbers are likely to be image-dependent.\nσ = 25μm\nsigmahp = Float64[σ/x for x in ps]\nsigmalp = zero(sigmahp)  # lowpass filtering is not currently recommended\n\n# The pco cameras have a bias of 100 in \"digital number\"\n# units. Convert this into the units of the image intensity.\n# If you're using a different camera, or using a PMT, this won't apply to you.\n# If you don't know anything better, you can set\n#     bias = zero(eltype(img0))\nbias = reinterpret(eltype(img), UInt16(100))\npp = PreprocessSNF(bias, sigmalp, sigmahp)","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"If you're using such pre-processing, it's important to apply it consistently to both the fixed and moving images:","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"# To apply it to your fixed image:\nfixed = pp(fixed)\n\n# To pass it to the workers: use it as an argument to the algorithm\nalgorithm = [Apertures(fixed, nodes, mxshift, λ, pp; pid=wpids[i], correctbias=false) for i = 1:length(wpids)]","category":"page"},{"location":"calcium_imaging/#Temporal-median-filtering-1","page":"Notes on registering biological sequences","title":"Temporal median filtering","text":"","category":"section"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"To reduce the impact of calcium \"sparks,\" sometimes it is useful to apply temporal median filtering to your images. For this task, mapwindow! from ImageFiltering is recommended. You can pre-allocate the output data file as a mmapped array:","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"using Mmap, ImageFiltering\n\n# Specify the filtering window. This example is for an image sequence that\n# has 3 spatial dimensions followed by one temporal dimension\nconst window = (1, 1, 1, 7)\n\nopen(\"my_filtered_data.dat\", \"w+\") do io\n    out = Mmap.mmap(io, Array{eltype(img),ndims(img)}, size(img))\n    mapwindow!(median!, out, img, window)\nend","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"mapwindow! also allows you to write out fewer time-slices than are present in the original image; see the indices keyword.","category":"page"},{"location":"calcium_imaging/#Artifact-removal-1","page":"Notes on registering biological sequences","title":"Artifact removal","text":"","category":"section"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"Sometimes a very bright blob might float past your preparation. Even if it doesn't enter into the area where there are cells, it can bias the results. One can set voxels of fixed outside the region of interest to NaN, reducing the likelihood that such events become problematic.  ","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"If the artifacts are much brighter than the tissue, one can also use mappedarray to set them to NaN in the moving images:","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"const badthresh = 12345\nimgthresh = mappedarray(x->x>badthresh ? nan(typeof(x)) : x, img)  # need ColorVectorSpace","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"For this to work you need to have your image encoded using a number type that supports NaN, but you can also do this lazily with mappedarray (or use MappedArrays' of_eltype).","category":"page"},{"location":"calcium_imaging/#Fixed-image-selection-1","page":"Notes on registering biological sequences","title":"Fixed image selection","text":"","category":"section"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"If your experiment involves stimuli, it can often be best to select your fixed image so that it does not include a strong response to stimuli.","category":"page"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"This task is likely to be quite specific to individual users' experiments, so no \"canned\" routines are provided. HolyLab members performing olfaction experiments may want to use some of the utilities in LabShare/Jerry/juliafunc/Jerry_RegisterUtils.","category":"page"},{"location":"calcium_imaging/#Registering-a-subset-of-images-1","page":"Notes on registering biological sequences","title":"Registering a subset of images","text":"","category":"section"},{"location":"calcium_imaging/#","page":"Notes on registering biological sequences","title":"Notes on registering biological sequences","text":"Typically the change of a tissue's shape is gradual. Routines here allow you to compute the deformation for a subset of images and then use linear interpolation in the time dimension to fill in intermediate time points. See tinterpolate.","category":"page"},{"location":"#RegisterWorkerApertures.jl-1","page":"Home","title":"RegisterWorkerApertures.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package provides convenient distributed computing support for the [BlockRegistration] suite of image registration packages. The overall task is organized by a \"driver\" process (RegisterDriver), which assigns individual images (which may be 2d or 3d) to \"workers\" which perform the computations of registration.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Both CPU and GPU computing are supported; for GPU computing you should have one device (one GPU card) per worker.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If your images are not large, you may find it easier to use BlockRegistration directly. It's recommended that you read the documentation of that package before starting with this one.","category":"page"}]
}
